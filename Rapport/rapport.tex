\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\rhead{Microprocesseur RISC-V}
\lhead{Systèmes Numériques 2025 -2026}
\rfoot{\thepage}

\lstdefinestyle{python}{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    frame=single,
    breaklines=true,
    language=Python,
    showstringspaces=false
}

\lstdefinestyle{asm}{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    numbers=left,
    numberstyle=\tiny\color{gray},
    frame=single,
    breaklines=true,
}

\title{
\vspace{-2cm}
\hrule
\vspace{0.5cm}
\textbf{\Huge Microprocesseur RISC-V 32 bits}\\[0.3cm]
\Large Systèmes Numériques 2025-2026\\[0.2cm]
\vspace{0.5cm}
\hrule
}
\author{Assim Farsi \and Félix Landreau \and Hugo Dischert \and Séphora Bennaoum }
\date{\today}

\begin{document}

\maketitle

Ce rapport présente l'implémentation d'un microprocesseur RISC-V 32 bits. Le projet comprend un CPU, une tentative de CPU pipelinée, un assembleur/compilateur, et des programmes de démonstration dont une horloge temps réel. Le microprocesseur est simulé grâce à un simulateur de netlists en OCaml. Le code et la mémoire du processus partagent des espaces d'adressage séparés (architecture de Harvard). 

\section{Introduction}

L'objectif de ce projet est de concevoir un microprocesseur capable d'exécuter un sous-ensemble de l'architecture RISC-V. Le projet comprend plusieurs composants :

\begin{itemize}
    \item {CPU} : execute une instruction par cycle
    \item {Compiler} : assembleur RISC-V vers code machine
    \item {Simulateur de netlist}
    \item {Horloge}
    \item {CPU\_pipeline} : tentative d'optimisation du circuit
\end{itemize}

\subsection{Architecture}
Nous avons:
\begin{itemize}
    \item des instructions de base 32 bits (arithmétique, logique, etc.)
    \item un multiplieur et un diviseur
\end{itemize}

Le processeur est décrit en Python à l'aide de la bibliothèque \texttt{lib\_carotte}, qui génère des netlists qui peuvent ensuite être simulées. Le processeur exécute une instruction complète à chaque cycle d'horloge.

\section{Composants}

\subsection{Unité arithmétique et logique}
L'\textbf{unité arithmétique (arith\_unit.py)} implémente l'addition et la soustraction sur $n$ bits. La soustraction $a - b$ est réalisée par $a + \overline{b} + 1$ (CA2).
L'\textbf{ALU (alu.py)} combine quant à elle les opérations arithmétiques et logiques.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|l|}
\hline
000 & ADD & SUB & Addition / Soustraction \\
001 & SLL & SUB & Shift Left Logical / Soustraction \\
010 & AND & AND & ET logique \\
011 & OR & OR & OU logique \\
100 & XOR & XOR & OU exclusif \\
101 & SLT & SLT & Set Less Than (signé) \\
110 & SRL & SRA & Shift Right Logical / Arithmetic \\
111 & SLTU & SLTU & Set Less Than (non signé) \\
\hline
\end{tabular}
\end{table}
\newpage
\subsection{Drapeaux/Flags}
Les drapeaux (flags.py) sont calculés pour les comparaisons et branchements conditionnels : Zero Flag (ZF), Carry/Borrow Flag (CF), Sign Flag (SF) et Negative Flag (NF).

\subsection{Multiplieur et diviseur}

Le \textbf{multiplieur} (multiplier.py) effectue des multiplications signées et non signées sur 32 bits, produisant un résultat sur 64 bits. Le \textbf{diviseur} (divider.py) calcule le quotient et le reste pour des opérandes signés ou non signés.
\subsection{Registre}

Le processeur dispose de 32 registres de 32 bits. Le registre x0 est à zéro. Il y a deux types de registre : un pour le CPU sans pipeline, qui intègre Program Counter (regs.py), et un conçu spécialement pour la pipeline et plus simple (regs\_pipeline.py).

\section{Assembleur / Compilateur}

Le compilateur (compiler.py) traduit le code assembleur RISC-V en code machine. Il effectue deux passes sur le fichier source : \\
\textbf{1.} Le compilateur parcourt le fichier pour repérer tous les labels et mémoriser leur position (numéro de ligne de code). Les labels peuvent être nommésou numériques.
\textbf{2:} Le compilateur génère le code machine instruction par instruction.

\subsection{Utilisation du compilateur}

Pour compiler un fichier assembleur, il faut modifier la dernière ligne de \texttt{compiler.py} pour appeler la fonction \texttt{compile} avec le chemin du fichier :

\begin{lstlisting}[style=python]
if __name__ == "__main__":
    compile("mon_programme.s")
\end{lstlisting}

Puis exécuter : \texttt{python3 compiler.py}

Le code machine est généré dans le fichier \texttt{compile.out}, qui est mis dans la ROM du simulateur.

\subsection{Instructions}

\begin{itemize}
    \item \textbf{Arithmétique :} add, addi, sub, mul, mulh, mulhu, mulhsu, div, divu, rem, remu
    \item \textbf{Logique :} and, andi, or, ori, xor, xori
    \item \textbf{Décalages :} sll, slli, srl, srli, sra, srai
    \item \textbf{Comparaison :} slt, slti, sltu, sltui
    \item \textbf{Mémoire :} lw, sw
    \item \textbf{Branchements :} beq, bne, blt, bge, bltu, bgeu, bgt, ble, bgtu, bleu
    \item \textbf{Sauts :} jal, jalr, j, jr
    \item lui, auipc, mov, ret
\end{itemize}

\section{Tentative de pipeline (cpu\_pipeline.py)}
Nous avons essayé de développer une version pipelinée du processeur (cpu\_pipeline.py) dans le but d'améliorer les performances du microprocesseur déjà implémenté en exécutant plusieurs instructions en parallèle.\\

Un pipeline divise l'exécution d'une instruction en plusieurs étages. Pendant qu'une instruction est dans un étage, une autre peut être dans l'étage précédent, et ainsi de suite. Cela permet théoriquement d'exécuter une instruction par cycle une fois le pipeline rempli. 
\begin{enumerate}
    \item \textbf{IF (Instruction Fetch)} : Lecture de l'instruction depuis la ROM à l'adresse pointée par le PC.
    \item \textbf{ID (Instruction Decode)} : Décodage de l'instruction et lecture des registres sources rs1 et rs2.
    \item \textbf{EX (Execute)} : Exécution de l'opération dans l'ALU et calcul des conditions de branchement.
    \item \textbf{MEM (Memory)} : Accès à la RAM pour les instructions load et store.
    \item \textbf{WB (Write Back)} : Écriture du résultat dans le registre destination.
\end{enumerate}

Entre chaque étage, des registres inter-étages (IF/ID, ID/EX, EX/MEM, MEM/WB) mémorisent les données nécessaires pour l'étage suivant.\\

Le pipeline introduit des problèmes appelés \textit{aléas ou hazards}. Ce sont des situations où une instruction ne peut pas s'exécuter correctement car elle dépend d'une instruction précédente qui n'a pas encore terminé. Cela survient quand une instruction a besoin d'une donnée qui n'est pas encore disponible. Par exemple :
\begin{lstlisting}[style=asm]
    add x1, x2, x3    ; ecrit x1 au cycle 5 (WB)
    sub x4, x1, x5    ; lit x1 au cycle 3 (ID) 
\end{lstlisting}
Ici, l'instruction \texttt{sub} essaie de lire x1 alors que \texttt{add} ne l'a pas encore écrit. Sans correction, \texttt{sub} lirait une ancienne valeur de x1.

Un aléa de contrôle survient lors d'un branchement. On ne sait pas si le branchement sera pris tant que la condition n'est pas évaluée (étage EX). Entre-temps, des instructions ont déjà été chargées dans le pipeline. Le \textbf{forwarding} (\texttt{forwarding.py}) permet de résoudre la plupart des aléas de données sans perdre de cycles. L'idée est de transmettre directement le résultat d'un étage vers l'entrée de l'ALU, sans attendre qu'il soit écrit dans les registres. Concrètement, avant d'utiliser une valeur de registre dans l'étage EX, on vérifie si cette valeur est en train d'être calculée par une instruction précédente encore dans le pipeline :
\begin{itemize}
    \item Si le registre source correspond au registre destination de l'instruction en EX/MEM, on utilise directement la sortie de l'ALU de cette instruction.
    \item Sinon, si le registre correspond à celui de l'instruction en MEM/WB, on utilise la donnée qui va être écrite.
    \item Sinon, on utilise la valeur normale lue depuis les registres.
\end{itemize}
Le forwarding depuis EX/MEM est prioritaire sur celui depuis MEM/WB, car il contient la valeur la plus récente.

La détection des hazards (\texttt{hazards.py}) vérifie si l'instruction en EX est un load et si l'instruction en ID utilise le même registre destination.
Quand un branchement est pris, les instructions qui ont été chargées après lui (dans IF et ID) ne doivent pas être exécutées. On les annule en les remplaçant par des bulles (on met leur registre destination à x0).

\subsection{État actuel du pipeline}

La version pipelinée génère une netlist. Cependant, elle ne peut pas être lancée avec la clock et rencontre des erreurs. De plus, le simulateur de netlists actuel ne permet pas de visualiser l'exécution parallèle des étages.\\
Pour générer et simuler le CPU avec pipeline :

\begin{enumerate}
    \item Compiler le circuit : \texttt{make cpu\_pipeline}
    \item Lancer la simulation : \texttt{make sim\_pipeline}
    \item Quand le simulateur demande le fichier ROM, indiquer le chemin vers le programme compilé (ex: \texttt{./compile.out})
\end{enumerate}


\section{Horloge}
clock.s incrémente les secondes, minutes et heures.
clock\_real\_time.s pemet d'avoir une horloge en temps réel.

\section{Tests et  utilisation}
Par défaut, les chemins sont correct si ces trois dossiers sont côte à côte :
\begin{itemize}
    \item \texttt{Sysnum\_microprocessor}
    \item \texttt{carotte.py (https://github.com/CarottePy/carotte.py)} : fichier carotte.py dans le dossier 
    \item \texttt{Netlist\_simulator (https://github.com/Acssiohm/Netlist\_simulator)} : fichier netlist\_simulator.byte dans le dossier 
\end{itemize}

Une fois les bons chemins relatifs mis à jour, on peut :
\begin{itemize}
    \item compiler un circuit circuit.py avec : make circuit
    \item lancer la simulation du dernier ciruit compilé avec : make sim 
    \item  compiler puis simuler avec circuit.py : make circuit sim
    \item make cpu : compile le CPU monocycle
    \item make cpu\_pipeline : compile le CPU pipeliné
    \item pour supprimer les fichiers produits par make : make clean
\end{itemize}    
Concernant le compilateur : \\
Il faut écrire le code assembleur dans un fichier, puis appeler la fonction python "compile" sur le chemin relatif du fichier, par exemple :
compile("compiler\_test.ass")
Le code produit est mis dans le fichier compile.out.\\

Le code produit peut alors être exécuté par le CPU, en le lançant avec make cpu sim puis en indiquant l'emplacement du code à exécuter (./compile.out). \\

\section{Conclusion}

Ce projet a permis de concevoir :

\begin{itemize}
    \item Un processeur RISC-V 32 bits avec multiplicateur et diviseur
    \item Un  compilateur qui traduit le code assembleur
    \item Une horloge pour l'application
    \item Une tentative de version de cpu pipelinée avec forwarding et gestion des hazards
\end{itemize}

\end{document}
